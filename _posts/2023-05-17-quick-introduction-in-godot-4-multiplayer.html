---
layout: post
title: Quick introduction in Godot 4 Multiplayer
tag:
- game-development
- godot-4
- godot-engine
- godot
- programming
---

<p>Greetings to everyone! Today I bring you a quick introduction to Godot version 4 multiplayer.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*p4vBXVLhwr_A3n9A.png" /></figure><p>If you want a better understanding, I recommend you read the <a href="https://godotengine.org/article/multiplayer-in-godot-4-0-scene-replication/">documentation</a> or at least know the differences between server-side and client-side. With that said, let’s go straight into it.</p><h3>Setup the Network</h3><p>This is similar to Godot 3.5, but the syntax is a little bit different:</p><p>For example, now everything about multiplayer is actually under a global class named “multiplayer” (MultiplayerAPI), meaning when we connect signals, it’s under the multiplayer class.</p><pre># GODOT 3.5<br>get_tree().connect(&quot;connected_to_server&quot;, self, &quot;_connected_to_server&quot;)<br># GODOT 4<br>multiplayer.connected_to_server.connect(self._connected_to_server)</pre><p>For quick setup, you can use this code:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5f6bde75c622a4a6510fb1500ba0d209/href">https://medium.com/media/5f6bde75c622a4a6510fb1500ba0d209/href</a></iframe><p>This code you will add as auto-load and then a create node with lobby and connect the signals, then button to switch scenes. To better understand the code, you can check my <a href="https://medium.com/@bitr13x/how-to-make-a-simple-2d-multiplayer-game-in-godot-6247b68d0af0">previous guide</a> to multiplayer 3.5.</p><h3>Multiplayer Synchronizer</h3><p>In this version of Godot, they added the multiplayer synchronizer, which simplifies the programming of multiplayer. Now you need to add it to the player tree, and then just set the properties that you want to synchronize.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DxqiAwZZx7rZoGDVM0SF2A.png" /></figure><p>This is so helpful and can save you a lot of time.</p><h3>Multiplayer Spawner</h3><p>Another new feature that also simplifies the process of spawning and managing networked objects in multiplayer games</p><p>But when I was using it, I fell into lots of errors, and then I just implemented my own spawner. If you want to play with it on your own, I recommend you look up the <a href="https://docs.godotengine.org/en/stable/classes/class_multiplayerspawner.html">documentation</a>.</p><h3>RPC Calls</h3><p>RPCs are essential for implementing networked gameplay and interactions, and that’s why it’s useful to know how to use them properly.</p><p>RPC changed syntax to a much simpler version.</p><p>For example, now you don’t have any master, puppet, remote, etc., but you have much simpler syntax.</p><h4>Syntax of RPC Calls in Godot 4:</h4><p>You will start with “@”, and then you will specify RPC’s mode, sync, transfer_mode.</p><pre># mode, sync, transfer_mode (order doesn&#39;t matter)<br># reliable -&gt; tcp, unreliable -&gt; udp (spamming), unreliable_ordered<br>@rpc(&quot;any_peer&quot;, &quot;call_local&quot;, &quot;reliable&quot;)<br>func totaly_sync():<br>  print(&quot;Running locally and any_connected_client running this function&quot;)<br><br>@rpc(&quot;call_local&quot;)<br>func local_call():<br>  print(&quot;calling just local function&quot;)<br><br># You also can use different channels used mostly for optimizations <br>@rpc(any_peer, 1)<br>func my_chat_func(message):<br> print(&quot;RPC received on channel 1, message: &quot; + str(message))<br><br># Calling rpc function:<br># rpc() == self.rpc<br>rpc(&quot;totaly_sync&quot;)<br># with arguments:<br>rpc(&quot;my_chat_func&quot;, &quot;Hello&quot;)</pre><p>But be careful, you can’t send any node because that could lead to an RCE vulnerability, so you need to work around it. Usually, I declare a list of items that I want to sync and then just send the index through the network.</p><pre>@onready var items = [<br> preload(&quot;res://path/to/scene.tscn&quot;),<br> preload(&quot;res://path/to/scene.tscn&quot;),<br>]<br><br>@rpc(&quot;any_peer&quot;, &quot;call_local&quot;, &quot;reliable&quot;)<br>func sync_items(index: int) -&gt; void:<br> spawn_item(items[index])</pre><h3>Controlling the execution flow</h3><p>The last thing on our list is how to actually control the execution flow. The main way to control the flow is by:</p><pre># check whoever executing the code if its the owner of current node<br>mutiplayer.is_mutliplayer_authority()<br># check if its the server<br>multiplayer.is_server()<br># set the ownership of the node<br>NODE.set_multiplayer_authority()<br></pre><p>When you instancing the player, you need to set him as the multiplayer_authority of its node. This will make your life much simpler.</p><p>And keep in mind that when using the “_ready()” function, the execution of this function usually happens before the multiplayer_authority is set.</p><h3>Conclusion</h3><p>With this article, you should be able to program multiplayer into your game. Sometimes multiplayer can be a pain because something is not syncing properly, and debugging the error is a little bit difficult, but with a cool head, you eventually find the error and gain a little bit more knowledge.</p><p>If you enjoyed this article, clap and follow me! Thanks for reading, and I wish you the best luck on your journey.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ed7e35cbfec5" width="1" height="1" alt="">
