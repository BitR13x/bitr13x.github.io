---
layout: post
title: 'TryHackMe CTF HackfinityBattle Writeup: Reverse Engineering (computemagic,
  oldauth)'
tag:
- tryhackme
- reverse-engineering
- ctf
- cybersecurity
---

<p>In this article, we will look into the process of solving two reverse engineering challenges from the TryHackMe CTF event. Step-by-step breakdown of how to approach and solve these puzzles.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*wA6dJ8KKstpQZZcr.png" /></figure><p>The original binaries are saved <a href="https://github.com/BitR13x/CTF-Collection/tree/main/Hackinfinity/reverse_engineering">here</a>.</p><h3>Recommended knowledge</h3><p>First get familiar with C (often you will end-up in de-compiler), it is very useful to learn little bit of assembly, registers and calling conventions if you need to use GDB.</p><p>Most important is to learn how to google build-in functions and more.</p><h3>Few tips how to approach these types challenges</h3><p>Find your de-compiler (Ghidra, IDA, Binary ninja, cutter, radare2 and more), there are lot’s of options just find what you are comfortable.</p><p>I stick with Ghidra and cutter (switching to the cutter if Ghidra does not decompile built-in functions or cannot find the main, just to check).</p><p>Get the bigger picture do not look into one part of the code too long if you look at a function from a different part, you can spot what is it for and decide if you need to understand it.</p><p>When looking for the main function, look for common patterns (the main function is usually loaded in the same manner from the entry point of the binary).</p><p>Plot graph of the execution flow for bigger binaries, it can help with clarity.</p><p>Make comments (the same reason).</p><h3>Computemagic</h3><p>When opening a binary usually you would see weird names and types.</p><p>After some renaming and figuring out what does what. I end up with this code:</p><pre> <br>int main(int argc,char **argv) {<br>  int error_res;<br>  ssize_t read_return;<br>  long in_FS_OFFSET;<br>  undefined4 option_value;<br>  socklen_t address_len;<br>  int socket;<br>  int socket_filedesc;<br>  int check;<br>  size_t length;<br>  sockaddr socketAddr;<br>  char buffer [24];<br>  undefined8 local_10;<br>  <br>  local_10 = *(undefined8 *)(in_FS_OFFSET + 40);<br>  option_value = 1;<br>  address_len = 16;<br>  while( true ) {<br>                    /* int socket(int domain, int type, int protocol); */<br>    socket = ::socket(2,1,0);<br>    if (socket == 0) {<br>      perror(&quot;socket failed&quot;);<br>                    /* WARNING: Subroutine does not return */<br>      exit(1);<br>    }<br>    error_res = setsockopt(socket,1,15,&amp;option_value,4);<br>    if (error_res != 0) {<br>      perror(&quot;setsockopt failed&quot;);<br>                    /* WARNING: Subroutine does not return */<br>      exit(1);<br>    }<br>    socketAddr.sa_family = 2;<br>    socketAddr.sa_data[2] = &#39;\0&#39;;<br>    socketAddr.sa_data[3] = &#39;\0&#39;;<br>    socketAddr.sa_data[4] = &#39;\0&#39;;<br>    socketAddr.sa_data[5] = &#39;\0&#39;;<br>    socketAddr.sa_data._0_2_ = htons(9003);<br>    error_res = bind(socket,&amp;socketAddr,16);<br>    if (error_res &lt; 0) {<br>      perror(&quot;bind failed&quot;);<br>                    /* WARNING: Subroutine does not return */<br>      exit(1);<br>    }<br>    error_res = listen(socket,3);<br>    if (error_res &lt; 0) break;<br>    socket_filedesc = accept(socket,&amp;socketAddr,&amp;address_len);<br>    if (socket_filedesc &lt; 0) {<br>      perror(&quot;accept failed&quot;);<br>                    /* WARNING: Subroutine does not return */<br>      exit(1);<br>    }<br>    sendBanner(socket_filedesc);<br>    read_return = read(socket_filedesc,buffer,16);<br>    if (read_return &lt; 0) {<br>      perror(&quot;read failed&quot;);<br>                    /* WARNING: Subroutine does not return */<br>      exit(1);<br>    }<br>    length = strlen(buffer);<br>    if ((length != 0) &amp;&amp; (socketAddr.sa_data[length + 13] == &#39;\n&#39;)) {<br>      socketAddr.sa_data[length + 13] = &#39;\0&#39;;<br>    }<br>    check = checkSpell(buffer,socket_filedesc);<br>    if (check == 1) {<br>      puts(&quot;\nSpell check successful.&quot;);<br>    }<br>    else {<br>      puts(&quot;\nSpell check failed.&quot;);<br>    }<br>    close(socket_filedesc);<br>    close(socket);<br>  }<br>  perror(&quot;listen failed&quot;);<br>                    /* WARNING: Subroutine does not return */<br>  exit(1);<br>}</pre><p>The binary starting a socket and waiting for connection.</p><p>Here is the most interesting parts of the code:</p><pre>socket_filedesc = accept(socket,&amp;socketAddr,&amp;address_len);<br>read_return = read(socket_filedesc,buffer,16);<br>length = strlen(buffer);<br>if ((length != 0) &amp;&amp; (socketAddr.sa_data[length + 13] == &#39;\n&#39;)) {<br>  socketAddr.sa_data[length + 13] = &#39;\0&#39;;<br>}<br>check = checkSpell(buffer,socket_filedesc);<br>if (check == 1) {<br>  puts(&quot;\nSpell check successful.&quot;);<br>}<br>else {<br>  puts(&quot;\nSpell check failed.&quot;);<br>}</pre><p>Now we know how large the input string must be and we know what function is used to validate if the input is correct.</p><pre>int checkSpell(char *buffer,int filedesc) {<br>  int return_val;<br>  size_t length;<br>  <br>  length = strlen(buffer);<br>  if ((int)length &lt; 1) {<br>    puts(&quot;Empty string.&quot;);<br>    return_val = 0;<br>  }<br>  else {<br>    switch(*buffer) {<br>    case &#39;A&#39;:<br>      func_1(buffer,filedesc);<br>      break;<br>    ...<br>    ...<br>    case &#39;Z&#39;:<br>      func_26(buffer,filedesc);<br>    }<br>    return_val = 1;<br>  }<br>  return return_val;<br>}</pre><p>Switch case, that is calling different functions depending on the first letter.</p><p>It can look complex, but I realized it has to take parameters in order to check the actual string and I end up look into each function that has parameters and found:</p><pre>void func_13(char *buf,int filedsc) {<br>  int result;<br>  <br>  result = check_other(buf);<br>  if (result != 0) {<br>    read_flag(filedsc);<br>  }<br>  return;<br>}</pre><p>Where the real validation happens:</p><pre><br>bool check_other(char *buf) {<br>  int res_strcmp;<br>  long in_FS_OFFSET;<br>  int i;<br>  char hardcoded [16];<br>  long canary;<br>  <br>  canary = *(long *)(in_FS_OFFSET + 40);<br>  // all what we need to reverse:<br>  for (i = 0; i &lt; 16; i = i + 1) {<br>    hardcoded[i] = buf[i] + 0x4U ^ 13;<br>  }<br><br>  res_strcmp = strcmp(hardcoded,&quot;AhhF1ag1571GHFDS&quot;);<br>  if (res_strcmp != 0) {<br>    printf(&quot;Incorrect: %s\n&quot;,buf);<br>  }<br>  else {<br>    printf(&quot;Correct: %s\n&quot;,buf);<br>  }<br>  if (canary != *(long *)(in_FS_OFFSET + 40)) {<br>                    /* WARNING: Subroutine does not return */<br>    __stack_chk_fail();<br>  }<br>  return res_strcmp == 0;<br>}</pre><p>Which I reverse by using python (the 0x4U means unsigned 4):</p><pre>a = &quot;AhhF1ag1571GHFDS&quot;<br>buf = [&quot;&quot;] * len(a)<br><br>for i in range(len(buf)):<br>    buf[i] = chr(ord(a[i]) + 4 ^ 13)<br><br>print(&quot;&quot;.join(buf)) # HaaG8hf8468FAGEZ</pre><h3>Oldauth</h3><p>Here is the same process rename everything and type it:</p><pre><br>int main(int argc,char **argv,char **envp) {<br>  bool bVar1;<br>  int iVar2;<br>  char *fgets_check;<br>  size_t newline_index;<br>  undefined7 extraout_var;<br>  undefined7 extraout_var_00;<br>  undefined7 extraout_var_01;<br>  undefined7 extraout_var_02;<br>  undefined4 in_register_0000003c;<br>  long in_FS_OFFSET;<br>  char username [112];<br>  char key [1000];<br>  long canary_bit;<br>  <br>  canary_bit = *(long *)(in_FS_OFFSET + 40);<br>  setup(CONCAT44(in_register_0000003c,argc));<br>  printf(&quot;Enter the key: &quot;);<br>  fgets_check = fgets(key,1000,stdin);<br>  if (fgets_check == (char *)0) {<br>    puts(&quot;Error!&quot;);<br>    iVar2 = -1;<br>  }<br>  else {<br>    newline_index = strcspn(key,&quot;\n&quot;);<br>    key[newline_index] = &#39;\0&#39;;<br>                    /* xor by 82 every char<br>                        */<br>    change(key,newline_index,82);<br>    if (newline_index != 16) {<br>                    /* <br>                        */<br>      fail();<br>    }<br>    if (key[2] != &#39;Q&#39;) {<br>      fail();<br>    }<br>    if (key[13] != &#39;4&#39;) {<br>      fail();<br>    }<br>                    /* suma of chars and modulo (4: how many chars, 3: modulo) */<br>    bVar1 = check(key,4,3);<br>    if ((int)CONCAT71(extraout_var,bVar1) == 0) {<br>      fail();<br>    }<br>    bVar1 = check(key + 4,5,8);<br>    if ((int)CONCAT71(extraout_var_00,bVar1) == 0) {<br>      fail();<br>    }<br>    bVar1 = check(key + 8,4,5);<br>    if ((int)CONCAT71(extraout_var_01,bVar1) == 0) {<br>      fail();<br>    }<br>    bVar1 = check(key + 12,4,3);<br>    if ((int)CONCAT71(extraout_var_02,bVar1) == 0) {<br>      fail();<br>    }<br>    printf(&quot;Enter the username: &quot;);<br>    fgets_check = fgets(username,100,stdin);<br>    if (fgets_check == (char *)0) {<br>      puts(&quot;Error!&quot;);<br>      iVar2 = -1;<br>    }<br>    else {<br>      newline_index = strcspn(username,&quot;\n&quot;);<br>      iVar2 = compare_with_target(username,newline_index);<br>      if (iVar2 == 0) {<br>        fail();<br>      }<br>      succeed();<br>      iVar2 = 0;<br>    }<br>  }<br>  if (canary_bit != *(long *)(in_FS_OFFSET + 40)) {<br>                    /* WARNING: Subroutine does not return */<br>    __stack_chk_fail();<br>  }<br>  return iVar2;<br>}</pre><p>Find interesting parts of code:</p><p>(I’ve named the first input as key)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/557/1*HXLml5CZaEt0EmEN9mAUnA.png" /><figcaption>This tells us the size and few letters</figcaption></figure><p>Next there is called four times on an input check function.</p><pre>    bVar1 = check(key,4,3);<br>    if ((int)CONCAT71(extraout_var,bVar1) == 0) {<br>      fail();<br>    }<br>    bVar1 = check(key + 4,5,8);<br>    if ((int)CONCAT71(extraout_var_00,bVar1) == 0) {<br>      fail();<br>    }<br>    bVar1 = check(key + 8,4,5);<br>    if ((int)CONCAT71(extraout_var_01,bVar1) == 0) {<br>      fail();<br>    }<br>    bVar1 = check(key + 12,4,3);<br>    if ((int)CONCAT71(extraout_var_02,bVar1) == 0) {<br>      fail();<br>    }</pre><p>After some adjustments for the function:</p><pre>bool check(char *key,int for_end,int modulo) {<br>  int suma;<br>  int i;<br>  <br>  suma = 0;<br>  for (i = 0; i &lt; for_end; i = i + 1) {<br>    suma = suma + key[i];<br>  }<br>  return suma % modulo == 0;<br>}</pre><p>I also noticed a second <em>fgets</em> meaning there are two parts (password and username). I started with reversing the check function using python:</p><pre>key = [&quot;&quot;, &quot;&quot;, &quot;Q&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;4&quot;, &quot;&quot;, &quot;&quot;]<br>def rev_check(start, end, modulo):<br>    suma = 0<br>    def_letter = &quot;d&quot;<br>    for i in range(start, start+end):<br>        if not key[i]:<br>            key[i] = def_letter<br>        <br>        suma += ord(key[i])<br><br>    if suma % modulo != 0:<br>        tmp = suma % modulo<br>        key[i] = chr(ord(def_letter) - tmp)<br><br># from the binary<br>rev_check(0, 4, 3)<br>rev_check(4, 5, 8)<br>rev_check(8, 4, 5)<br>rev_check(12, 4, 3)<br><br>print(&quot;REV Check:&quot;, key)<br>for c in range(len(key)):<br>    key[c] = chr(ord(key[c]) ^ 82)<br><br>print(&quot;XOR:&quot;, key)<br><br>with open(&quot;rev_out&quot;, &quot;w&quot;) as f:<br>    f.write(&quot;&quot;.join(key))<br><br>print(&quot;password:&quot;, &quot;&quot;.join(key).encode())</pre><p>Not the prettiest code, but hey it works.</p><p>2nd part is username:</p><pre>    printf(&quot;Enter the username: &quot;);<br>    fgets_check = fgets(username,100,stdin);<br>    if (fgets_check == (char *)0) {<br>      puts(&quot;Error!&quot;);<br>      iVar2 = -1;<br>    }<br>    else {<br>      newline_index = strcspn(username,&quot;\n&quot;);<br>      iVar2 = compare_with_target(username,newline_index);<br>      if (iVar2 == 0) {<br>        fail();<br>      }<br>      succeed();<br>      iVar2 = 0;<br>    }</pre><p>Noticed that there is called the <em>compare_with_target</em> function, to check if the username is correct.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/467/1*5qg_WrTfl5JoqVEGBGmPLw.png" /></figure><p>Don’t get confused with the return “!=” it has to return the “<em>1”.</em></p><p>This function is a straight forward checking hard-coded variable with a small ASCII shift (+2).</p><p>The reverse of this function in python would look like this:</p><pre># username<br>username = &quot;&quot;<br>for c in &quot;elb4rt0pwn&quot;:<br>    username += chr(ord(c) - 2)<br><br>print(&quot;username:&quot;, username)</pre><p>After sending it all together into the binary you would get a flag.</p><h3>Final words</h3><p>Thanks for reading, if someone is interested in collaboration write me on discord (bitr13x) or email me (<a href="mailto:sw33tbit@protonmail.com">sw33tbit@protonmail.com</a>).</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ae99c70409c5" width="1" height="1" alt="">
