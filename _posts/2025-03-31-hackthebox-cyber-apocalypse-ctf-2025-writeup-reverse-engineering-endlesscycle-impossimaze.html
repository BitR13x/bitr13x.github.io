---
layout: post
title: 'HackTheBox Cyber Apocalypse CTF 2025 writeup: Reverse Engineering (endlesscycle,
  impossimaze)'
tag:
- cybersecurity
- hackthebox
- reverse-engineering
- ctf-writeup
---

<p>Two easy rated challenges from the HackTheBox CTF event. In this article we look into the Step-by-step breakdown of how to approach and solve these challenges.</p><p>The original binaries are saved <a href="https://github.com/BitR13x/CTF-Collection/tree/main/Cyber%20Apocalypse%202025">here</a>.</p><h3>Endlesscycle</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/986/1*RldR_Q_SXRC1TYF7fmVpVA.png" /></figure><p>After de-compilation and renaming I end-up with this code:</p><pre>int main(int argc,char **argv) {<br>  int iVar1;<br>  char *pcVar2;<br>  int i;<br>  int i2;<br>  <br>  pcVar2 = (char *)mmap((void *)0,158,7,33,-1,0);<br>                    /* 3486694491 */<br>  srand(UINT_001042b8);<br>  for (_i = 0; _i &lt; 158; _i = _i + 1) {<br>    for (_i2 = 0; _i2 &lt; (ulong)(long)INT_ARRAY_00104040[_i]; _i2 = _i2 + 1) {<br>      rand();<br>    }<br>    iVar1 = rand();<br>    pcVar2[_i] = (char)iVar1;<br>  }<br>                    /* construct function using rand */<br>  iVar1 = (*(code *)pcVar2)();<br>  if (iVar1 == 1) {<br>    puts(&quot;You catch a brief glimpse of the Dragon\&#39;s Heart - the truth has been revealed to you&quot;);<br>  }<br>  else {<br>    puts(&quot;The mysteries of the universe remain closed to you...&quot;);<br>  }<br>  return 0;<br>}</pre><p>This binary is initialized with srand and creates a function based on the rand function and it should be possible to recreate this function by setting the srand (for example in python), but I choose the easiest way by examining it in GDB.</p><pre>=&gt; 0x7ffff7fbf000: push   rbp // init<br>   0x7ffff7fbf001: mov    rbp,rsp<br>   0x7ffff7fbf004: push   0x101213e<br>   0x7ffff7fbf009: xor    DWORD PTR [rsp],0x1010101 <br>                           // 0x101213e ^ 0x101213e <br>   0x7ffff7fbf010: movabs rax,0x67616c6620656874<br>   0x7ffff7fbf01a: push   rax<br>   0x7ffff7fbf01b: movabs rax,0x2073692074616857<br>   0x7ffff7fbf025: push   rax<br>   0x7ffff7fbf026: push   0x1<br>   0x7ffff7fbf028: pop    rax<br>   0x7ffff7fbf029: push   0x1<br>   0x7ffff7fbf02b: pop    rdi<br>   0x7ffff7fbf02c: push   0x12<br>   0x7ffff7fbf02e: pop    rdx<br>   0x7ffff7fbf02f: mov    rsi,rsp<br>   0x7ffff7fbf032: syscall // write 18 bytes from stack f01b, f010<br>                              // What is the flag?<br>   0x7ffff7fbf034: sub    rsp,0x100 // 256 bytes reserved for buffer<br>   0x7ffff7fbf03b: mov    r12,rsp<br>   0x7ffff7fbf03e: xor    eax,eax <br>   0x7ffff7fbf040: xor    edi,edi<br>   0x7ffff7fbf042: xor    edx,edx // cleaning<br>   0x7ffff7fbf044: mov    dh,0x1<br>   0x7ffff7fbf046: mov    rsi,r12<br>   0x7ffff7fbf049: syscall         // read into r12<br>   0x7ffff7fbf04b: test   rax,rax // if read is not empty<br>   0x7ffff7fbf04e: jle    0x7ffff7fbf082<br><br><br>   // for loop sliding 4 bytes with xor<br>   0x7ffff7fbf050: push   0x1a // 26<br>   0x7ffff7fbf052: pop    rax<br>   0x7ffff7fbf053: mov    rcx,r12 // rcx = r12<br>   0x7ffff7fbf056: add    rax,rcx // rax += rcx + 26<br>   0x7ffff7fbf059: xor    DWORD PTR [rcx],0xbeefcafe<br>   0x7ffff7fbf05f: add    rcx,0x4 // rcx += 4<br>   0x7ffff7fbf063: cmp    rcx,rax // if rcx &lt; rax<br>   0x7ffff7fbf066: jb     0x7ffff7fbf059<br><br><br>   0x7ffff7fbf068: mov    rdi,r12<br>   0x7ffff7fbf06b: lea    rsi,[rip+0x12]        # 0x7ffff7fbf084<br>   0x7ffff7fbf072: mov    rcx,0x1a<br>   0x7ffff7fbf079: cld<br><br>   // comparing rdi (r12, input) with rsi (0x1a bytes = 26 bytes)<br>   0x7ffff7fbf07a: repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi]<br>   0x7ffff7fbf07c: sete   al<br>   0x7ffff7fbf07f: movzx  eax,al<br>   0x7ffff7fbf082: leave<br>   0x7ffff7fbf083: ret</pre><p>You can notice on the end there is a comparison RDI with RSI, where RDI is input. I dumped the memory:</p><pre>// 0x7ffff7fbf084: memory dump<br>0x7ffff7fbf084:   0xb6  0x9e  0xad  0xc5  0x92  0xfa  0xdf  0xd5<br>0x7ffff7fbf08c:   0xa1  0xa8  0xdc  0xc7  0xce  0xa4  0x8b  0xe1<br>0x7ffff7fbf094:   0x8a  0xa2  0xdc  0xe1  0x89  0xfa  0x9d  0xd2<br>0x7ffff7fbf09c:   0x9a  0xb7</pre><p>When reconstructing the behavior in C it should look something like this:</p><pre>int main() {<br>    char buffer[256];<br>    char message[] = &quot;What is flag?&quot;;<br>    char expected[] = &quot;...&quot;; // 0x7ffff7fbf084<br>    ssize_t bytes_read;<br>    <br>    // Print message<br>    write(STDOUT_FILENO, message, sizeof(message) - 1);<br>    <br>    // Read user input<br>    bytes_read = read(STDIN_FILENO, buffer, 256);<br>    if (bytes_read &lt;= 0) {<br>        return 0;<br>    }<br>    <br>    // XOR first few bytes with 0xBEEFCAFE<br>    for (int i = 0; i &lt; bytes_read - 4; i += 4) {<br>        *(int *)(buffer + i) ^= 0xBEEFCAFE;<br>    }<br>    <br>    // Compare with expected string<br>    if (memcmp(buffer, expected, 26) == 0) {<br>        puts(&quot;You got the flag!&quot;);<br>        return 1;<br>    }<br>    <br>    puts(&quot;Try again...&quot;);<br>    return 0;<br>}</pre><p>So now we can get the hands on python and reverse it:</p><pre>import struct<br><br># copied from memory dump<br>encrypted_data = [<br>    0xb6, 0x9e, 0xad, 0xc5, 0x92, 0xfa, 0xdf, 0xd5,<br>    0xa1, 0xa8, 0xdc, 0xc7, 0xce, 0xa4, 0x8b, 0xe1,<br>    0x8a, 0xa2, 0xdc, 0xe1, 0x89, 0xfa, 0x9d, 0xd2,<br>    0x9a, 0xb7<br>]<br><br># the key that is used<br>xor_key = 0xBEEFCAFE<br><br>original_bytes = bytearray()<br>for i in range(0, len(encrypted_data), 4):<br>    # XOR is applied to 4-byte chunks<br>    chunk = encrypted_data[i:i+4]<br>    while len(chunk) &lt; 4:<br>        chunk.append(0)<br>    <br>    # unpack it into int and back<br>    # (reverse of XOR is another XOR with same value)<br>    encrypted_int = struct.unpack(&quot;&lt;I&quot;, bytes(chunk))[0]<br>    decrypted_int = encrypted_int ^ xor_key<br>    original_bytes.extend(struct.pack(&quot;&lt;I&quot;, decrypted_int))<br><br>original_input = original_bytes.decode(errors=&quot;ignore&quot;)<br><br>print(&quot;Original input:&quot;, original_input)</pre><p>Next on the list is:</p><h3><strong>Impossimaze</strong></h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/540/1*ufh8Zh8Lo5Ndy-tK1aQZmw.png" /></figure><p>When trying to make sense in the binary I’ve ended up with this code:</p><pre>int main(int argc,char **argv) {<br>  int iVar1;<br>  uint uVar2;<br>  uint max_y_2;<br>  uint max_x_2;<br>  ulong max_x;<br>  char char_to_write;<br>  int x;<br>  int y;<br>  int *char_index;<br>  undefined4 in_register_0000003c;<br>  long in_FS_OFFSET;<br>  int half_x;<br>  int max_y;<br>  char position_x_y [24];<br>  long canary;<br>  <br>  canary = *(long *)(in_FS_OFFSET + 40);<br>                    /* newterm(getenv(&quot;TERM&quot;), stdout, stdin); */<br>  initscr(CONCAT44(in_register_0000003c,argc));<br>  cbreak();<br>  noecho();<br>  curs_set(0);<br>  keypad(window,1);<br>  max_y = getmaxy(window);<br>  max_x = getmaxx(window);<br>                    /* ensures half */<br>  half_x = (int)(((uint)(max_x &gt;&gt; 31) &amp; 1) + (int)max_x) &gt;&gt; 1;<br>  max_y = max_y / 2;<br>  x = 0;<br>  do {<br>    max_y_2 = getmaxy(window);<br>    max_x_2 = getmaxx(window);<br>    if (x == 260) {<br>      half_x = half_x - (uint)(1 &lt; half_x);<br>    }<br>    else if (x &lt; 261) {<br>      if (x == 258) {<br>        max_y = max_y + 1;<br>      }<br>      else if (x == 259) {<br>        max_y = max_y - (uint)(1 &lt; max_y);<br>      }<br>    }<br>    else {<br>      half_x = half_x + (uint)(x == 261);<br>    }<br>    werase(window);<br>    wattr_on(window,1048576,0);<br>    wborder(window,0,0,0,0,0,0,0,0);<br>    if (2 &lt; (int)max_x_2) {<br>      x = 1;<br>      do {<br>        y = 1;<br>        if (2 &lt; (int)max_y_2) {<br>          do {<br>            uVar2 = get_char(x,y);<br>            if ((int)uVar2 &lt; 61) {<br>              char_to_write = &#39;A&#39;;<br>              if ((int)uVar2 &lt; 31) {<br>                char_to_write = (-(uVar2 &lt; 31) &amp; 133U) + 86;<br>              }<br>            }<br>            else {<br>              char_to_write = (-(uVar2 - 61 &lt; 120) &amp; 202U) + 86;<br>            }<br>            iVar1 = wmove(window,y,x);<br>            if (iVar1 != -1) {<br>              waddch(window,(int)char_to_write);<br>            }<br>            y = y + 1;<br>          } while (y != max_y_2 - 1);<br>        }<br>        x = x + 1;<br>      } while (max_x_2 - 1 != x);<br>    }<br>    wattr_off(window,1048576,0);<br>    wattr_on(window,2097152,0);<br>    x = wmove(window,max_y,half_x);<br>    if (x != -1) {<br>      waddch(window,88);<br>    }<br>    wattr_off(window,2097152,0);<br>    snprintf(position_x_y,16,&quot;%d:%d&quot;,(ulong)max_y_2,(ulong)max_x_2);<br>    x = wmove(window,0,0);<br>    if (x != -1) {<br>      waddnstr(window,position_x_y,4294967295);<br>    }<br>    if ((max_y_2 == 13) &amp;&amp; (max_x_2 == 37)) {<br>      wattr_on(window,524288,0);<br>      wattr_on(window,2097152,0);<br>      char_index = &amp;INT_001040c0;<br>      x = 6;<br>      do {<br>        y = x + 1;<br>        x = wmove(window,6,x);<br>        if (x != -1) {<br>                    /* add a character (with attributes) to a curses window and advance cursor  */<br>          waddch(window,(&amp;DAT_00104120)[*char_index]);<br>        }<br>        char_index = char_index + 1;<br>        x = y;<br>      } while (y != 30);<br>      wattr_off(window,2097152,0);<br>      wattr_off(window,524288,0);<br>    }<br>    x = wgetch(window);<br>  } while (x != 113);<br>  endwin();<br>  if (canary != *(long *)(in_FS_OFFSET + 40)) {<br>                    /* WARNING: Subroutine does not return */<br>    __stack_chk_fail();<br>  }<br>  return 0;<br>}</pre><p>This binary is keeping track of window size, position x-y and moving cursor using <em>wmove </em>and <em>waddch</em>.</p><p>My approach was to search for printing any method, that may print out our flag. There were a few functions that caught my eye:</p><pre>uVar2 = get_char(x,y);<br>if ((int)uVar2 &lt; 61) {<br>    char_to_write = &#39;A&#39;;<br>    if ((int)uVar2 &lt; 31) {<br>      char_to_write = (-(uVar2 &lt; 31) &amp; 133U) + 86;<br>    }<br>}<br>else {<br>  char_to_write = (-(uVar2 - 61 &lt; 120) &amp; 202U) + 86;<br>}<br><br>waddch(window,(int)char_to_write);<br><br>// Write formatted output to sized buffer<br>snprintf(position_x_y,16,&quot;%d:%d&quot;,(ulong)max_y_2,(ulong)max_x_2);<br>waddnstr(window,position_x_y,4294967295);<br><br>char_index = &amp;INT_001040c0;<br>waddch(window,(&amp;DAT_00104120)[*char_index]);</pre><p><em>waddch</em> is used add a character to a curses window and advance cursor.</p><p>So we got few options, we will try to eliminate it one by one by thinking what it does, the first is kind of complex shifting of the char depending on <em>get_char</em> function:</p><pre>int get_char(int x,int y) {<br>  return *(int *)(&amp;DAT_00102020 +<br>                 (long)((x + *(int *)(&amp;DAT_00102020 + (long)((y + 1337) % 256) * 4)) % 256) * 4);<br>}</pre><p>But I stepped out and was thinking about the “<strong><em>char_to_write = ‘A’;”</em></strong>, it seemed weird to me, so I moved on.</p><p>Next we just printing position x-y, that’s clearly not what we are searching for.</p><p>Moving on we end-up here:</p><pre>char_index = &amp;INT_001040c0;<br>waddch(window,(&amp;DAT_00104120)[*char_index]);</pre><p>I noticed that the <em>char_index</em> variable is actually an array of <em>ints</em> and if some conditions are met then the char is printed.</p><p>So I tried to extract some of the non-null ints from the memory and added it to the<em> DAT_00104120 </em>and what we got here: “<em>HTB{“</em>, beginning of the flag and I knew that I was on the right path.</p><pre>00104205 H<br>0010413c T<br>001041d8 B<br>001041d2 {<br>00104160 T<br>00104188 H<br>001041f2 3<br>001041aa _<br>00104170 c<br>001041a6 u<br>0010421c r<br>00104193 s<br>001041f2 3<br>001041aa _<br>0010420d i<br>00104193 s<br>001041aa _<br>00104165 b<br>0010421c r<br>00104176 o<br>001041eb k<br>001041f2 3<br>0010420f n<br>001041e0 }<br><br># HTB{th3_curs3_is_brok3n}</pre><h3>Final words</h3><p>Thanks for reading, if someone is interested in collaboration write me on discord (bitr13x) or email me (<a href="mailto:sw33tbit@protonmail.com">sw33tbit@protonmail.com</a>).</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=254b349ba227" width="1" height="1" alt="">
