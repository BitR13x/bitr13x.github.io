---
layout: post
title: Building your own network protection with Hybrid WAF and iptables
tag:
- network-security
- web-security
- firewall
- programming
- cybersecurity
---

<p>In this article I’ll introduce types of firewalls, more specifically IPS/IDS, WAF and iptables. And how to implement your own WAF and iptables rules with python.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WqQYvRdvibHXsNTplyHPfw.png" /><figcaption>Animated representation of firewall (taken from: exa.net.uk)</figcaption></figure><p>Code in this article is publicly available right here:</p><p><a href="https://github.com/BitR13x/AI-WAF">GitHub - BitR13x/AI-WAF: Web Firewall that is powered by AI and signatures</a></p><h3>So theory comes first, what is firewall?</h3><p>It is usually a hardware or software-based system which monitors all incoming and outgoing traffic and, based on a defined set of security rules, it accepts, rejects, or drops that specific traffic. Web application firewall (WAF) is simply a firewall for web application.</p><p>In order to secure the internal network from unauthorized traffic, we need a <a href="https://www.geeksforgeeks.org/introduction-of-firewall-in-computer-network/">Firewall</a>.</p><h4>How about the IPS/IDS?</h4><p><strong>Intrusion Detection System (IDS): </strong>Looking for the signature of known attack types or detecting activity that deviates from a prescribed normal and then report it.</p><p>I<strong>ntrusion Prevention System (IPS): </strong>Basically the same, but it can block the packet/request.</p><p>Example of an open-source IPS/IDS: <strong>Suricata</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/225/0*8aqm07E_PiaZUuxk" /><figcaption>Suricata icon</figcaption></figure><p>Interesting sources related to IPS/IDS:<br><a href="https://cheatography.com/g33k247/cheat-sheets/suricata-nsm-more-than-an-ids/">Suricata cheetsheet</a><br><a href="https://github.com/ntop/nDPI">nDIP</a> — Deep Packet Inspection<br><a href="https://github.com/noushinpervez/Intrusion-Detection-CICIDS2017">Intrusion-Detection-CICIDS2017</a> — in-depth analysis of the CICIDS2017 dataset</p><h4>Comparison IPS/IDS and firewall:</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/894/1*PCg59K37m1HcbnRTRwbyrA.png" /><figcaption>Table from chatgpt</figcaption></figure><p>The differences are on thin ice, so I will not go deeper, because you could argue that the WAF or iptables can detect attacks and block them, meaning it would be something more complex than just a firewall.</p><h3><strong>Let’s move on, implementation of iptables?</strong></h3><p>By combining iptables and Python, you can create a custom intrusion detection and prevention system (IDS/IPS) that can intercept network packets before they reach the target service.</p><p>For example, using libraries such as NFQueue or Scapy in Python, you can:</p><ul><li>Analyze packets in real time</li><li>Detect suspicious patterns</li><li>Perform an automated action (e.g. dropping a packet or blocking an IP address).</li></ul><p>For example, here is a python script that blocks all IP addresses that are not in <em>whitelist.txt</em>:</p><pre>def process_packet(packet):<br>    scapy_packet = IP(packet.get_payload())<br>    features = extract_features(scapy_packet, packet)<br>    with open(&quot;./whitelist.txt&quot;) as file:<br>        for line in file:<br>            if line[0] == &quot;&quot; or line[0] == &quot;\n&quot;:<br>                continue<br><br>            if scapy_packet.src == line.strip().replace(&quot;\n&quot;, &quot;&quot;):<br>                print(f&quot;❌ Dropping Packet: {scapy_packet.summary()}&quot;)<br>                packet.drop()<br>        <br>    packet.accept()<br><br><br># Start Netfilter Queue<br>nfqueue = NetfilterQueue()<br>nfqueue.bind(1, process_packet)<br><br>print(&quot;Monitoring Traffic in Real-Time&quot;)<br>try:<br>    nfqueue.run()<br>except KeyboardInterrupt:<br>    print(&quot;\nStopping Firewall...&quot;)<br>    nfqueue.unbind()</pre><p>It works by using <em>NFQUEUE</em>, which is queueing packets to userspace. In simple terms, you get access to the packet using python. But you need to specify a queue number:</p><pre>sudo iptables -D INPUT -p tcp --dport 80 -j NFQUEUE --queue-num 1</pre><p>And you can do pretty neat stuff with this.</p><h3>Implementation of WAF</h3><p>We need to intercept HTTP(S) requests before they are delivered to the target server. This gives us the ability to analyze the content of the request and decide if it contains potentially malicious code.</p><p>We implement this step using a reverse-proxy component that I have programmed in Python using the library HTTPServer (a possible different approach is with the mitmproxy library).</p><p>The reverse-proxy acts as an intermediary between the user and the server. All traffic goes through this proxy first, which then decides whether to forward the request.</p><p>(The whole code is in the repository mentioned in the introduction)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*RhBwYy7FD4myEppWoUgJcA.png" /><figcaption>Implemented WAF architecture</figcaption></figure><p>This is how we forward the request:</p><pre>def do_GET(self, body=True):<br>  url = protocol+f&#39;{hostname}{self.path}&#39;<br>  resp = requests.get(url, headers=self.headers, verify=False)<br>  self.wfile.write(resp.text.encode(encoding=&#39;UTF-8&#39;,errors=&#39;strict&#39;))</pre><p>If we want to check the URL, we simply do something like this:</p><pre>def do_GET(self, body=True):<br>  url = protocol+f&#39;{hostname}{self.path}&#39;<br>  if verify_url(self.path): # we know that hostname is safe (from init)<br>    resp = requests.get(url, headers=self.headers, verify=False)<br>    self.wfile.write(resp.text.encode(encoding=&#39;UTF-8&#39;,errors=&#39;strict&#39;))<br>  else:<br>    self.send_error(403, &quot;Not allowed&quot;)</pre><h4>Signature-based</h4><p>A signature-based WAF is a security mechanism designed to detect known patterns or signatures of malicious activity.</p><p>I’ve collected rules from <a href="https://github.com/coreruleset/coreruleset">coreruleset</a>, <a href="https://user-agents.net/">user-agents</a> and <a href="https://rules.emergingthreats.net/">suricata</a>.</p><p>Then made a regex search to match if any string is in the request or response.</p><pre>    def __get_files_in_dir(self, dir_path: str) -&gt; list:<br>        if os.path.isdir(dir_path):<br>            return os.listdir(dir_path)<br>        else:<br>            return []<br><br>    def __search_string_in_file(self, file_path: str, string: str) -&gt; bool:        <br>        with open(file_path, &quot;r&quot;) as f:<br>            for line in f:<br>                # empty line or comment<br>                if line[0] == &quot;#&quot; or line[0] == &quot;\n&quot;:<br>                    continue<br>                <br>                # remove newline<br>                if line[-1]:<br>                    line = line[:-1]<br><br>                if re.search(re.escape(line), string):<br>                    return True # packet dangerous<br><br>        return False<br><br>    def __verify_signature(self, string: str, var: str) -&gt; bool:<br>        files = self.__get_files_in_dir(self.signatures_paths[var])<br>        if len(files) &gt; 0:<br>            for file in files:<br>                file_path = os.path.join(relative_path(self.signatures_paths[var]), file)<br>                if self.__search_string_in_file(file_path, string):<br>                    return False<br>        <br>        # returning True if path does not exist!<br>        return True</pre><h4>AI-based</h4><p>AI-powered Web Application Firewall uses artificial intelligence and machine learning to detect and block web attacks in real time.</p><p>I used <a href="https://www.kaggle.com/datasets/evg3n1j/fwaf-dataset">fwaf-dataset</a> and <a href="https://github.com/swisskyrepo/PayloadsAllTheThings">PayloadAllThethings</a> to train two models using PyTorch.</p><p>I didn’t create new model, but fine-tuned <em>distilbert-base-uncased </em>(you can use<em> </em>llama or any different model for classification).</p><pre>    def verify_url(self, url: str) -&gt; bool:<br>        inputs = self.tokenizer(url,<br>            truncation=True,<br>            padding=True,<br>            return_tensors=&quot;pt&quot;,<br>            max_length=500<br>        ).to(self.device)<br><br>        with torch.no_grad():<br>            outputs = self.url_model(**inputs)<br><br>        probabilities = torch.nn.functional.softmax(outputs.logits, dim=-1)<br>        predicted_class_index = torch.argmax(probabilities, dim=-1).item()<br><br>        predicted_class_name = self.url_labels[predicted_class_index]<br>        logging.info(f&quot;Probabilities for each class: {probabilities.numpy()}: {predicted_class_name}&quot;)<br><br>        if max(probabilities[0]) &lt; self.probability_catch:<br>            # We are not that certain<br>            return True<br><br>        if predicted_class_name == &quot;goodqueries&quot;:<br>            return True<br>        else:<br>            return False</pre><h3>Main disadvantages</h3><p><strong>Complexity: </strong>Setting up and keeping up a firewall can be time-consuming and difficult<strong><br>Limited Flexibility for developers<br>Limited adaptability: </strong>frequently rule-based for signatures and AI can’t be that much trusted</p><h4>Possible upgrade to this project</h4><p>One option is anomaly-based detection.<br>Once we gather enough data to define normal network flow, we can take action on anomalies.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/550/0*peHxraS7p5QI45_B.png" /><figcaption>Abstract example of statistically represented network flow in graph</figcaption></figure><h3>Conclusion</h3><p>Creating a comprehensive security system for a server environment is not only possible, but also highly effective when using a combination of multiple layers of protection, including WAF and iptables.</p><p>A good security architecture can significantly reduce the risk of successful cyber-attacks such as XSS, XXE, CSRF, DDoS or SQL injection.</p><p>If you enjoyed this article, clap and follow me! Thanks for reading, and I wish you the best luck on your journey👋.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3e9d21b35c7a" width="1" height="1" alt=""><hr><p><a href="https://systemweakness.com/writing-your-own-network-protection-for-server-waf-and-iptables-3e9d21b35c7a">Building your own network protection with Hybrid WAF and iptables</a> was originally published in <a href="https://systemweakness.com">System Weakness</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
