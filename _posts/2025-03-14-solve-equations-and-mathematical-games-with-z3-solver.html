---
layout: post
title: Solve equations and mathematical games with Z3 solver
tag:
- hacking
- reverse-engineering
- programming
- cybersecurity
---

<p>How to efficiently solve problems ranging from simple mathematical equations to advanced logical satisfiability.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/540/1*2y4S8pFSL0YjvGiLuqOvaQ.png" /></figure><h3>What is Boolean Satisfiability (SAT) and Satisfiability Modulo Theories¬†(SMT)</h3><p><strong>Boolean Satisfiability </strong>abbreviated<strong> SAT.</strong> Boolean stands for True or False and satisfiability is when it is true under some assignment of values to its variables. Meaning <strong>SAT</strong> solvers trying to find if the variables can be replaced by the values TRUE or FALSE in such a way that the formula evaluates to TRUE. The standard definition is:</p><blockquote>SAT solvers determine the ‚Äòsatisfiability‚Äô of boolean set of equations for a set of¬†inputs.</blockquote><p>In other hand the SMT practically doing the same thing, but it combines the power of SAT solvers and other types of solvers to solve more complicated formulas for example handling inequalities, uninterpreted functions. SMT can handle formulas that involve multiple theories such as <strong>linear arithmetic</strong>, <strong>bit-vectors</strong>, and¬†<strong>arrays</strong>.</p><h3><strong>Intro into Z3¬†Solver</strong></h3><p>Why we were talking about <strong>SMT</strong> and <strong>SAT</strong>, because the <strong>Z3</strong> is <a href="https://smt-lib.org/solvers.shtml">one of the <strong>SMTs</strong></a><strong>. </strong>It can be used for a variety of purposes such as formal verification, model checking, static program analysis and lot¬†more.</p><p>Often when navigating through this field you will come across the terms¬†like:</p><p><strong>Symbols</strong> (= variables), <br><strong>Unsat/sat</strong> (= unsatisfiable/satisfiable), (= unsolvable/solvable)<br><strong>Concrete values</strong> (= strings, decimals and integers)<br><strong>Literals</strong> (= SAT variable in short)<br><strong>Clauses</strong> (= combination of literals)</p><h4>Bonus</h4><p><strong>P </strong>problem (Polynomial problem): Refers to problems that can be solved efficiently (in polynomial time [n¬≤ + n, n]) by a deterministic algorithm. Example: Sorting a¬†list.</p><p><strong>NP </strong>problem<strong> </strong>(Nondeterministic Polynomial problem): Refers to problems for which a solution can be quickly verified (in polynomial time). Example: Verifying a solution to a Sudoku¬†puzzle.</p><h3>How the Z3 actually works? Well here you¬†go:</h3><p>The fastest way how to demonstrate it, is how to solve Facebook¬†quiz:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/227/0*tllS_2trEwIevGkp" /></figure><p>We can rewrite it into Z3 form, where flowers will be the symbols (variables):</p><pre>from z3 import *<br><br># flowers =&gt; Symbolic [Int] type<br>rflower = Int(&quot;rflower&quot;)<br>bflower = Int(&quot;bflower&quot;)<br>yflower = Int(&quot;yflower&quot;)<br># rflower, bflower, yflower = Ints(&#39;rflower bflower yflower&#39;)<br><br>solver = Solver()<br><br># (Constraints) Equations<br>solver.add(rflower + rflower + rflower == 60)<br>solver.add(rflower + bflower + bflower == 30)<br>solver.add(bflower - yflower == 3)<br># note: if we know the result is positive, we can add constraint: flower &gt; 0<br><br># Solver.check =&gt; CheckSatResult[sat, unsat, unknown]<br>if solver.check() == sat:<br>    model = solver.model()<br>    print(&quot;Sat solution:&quot;)<br>    print(<br>        f&quot;Answer is: {model[yflower]} + {model[rflower]} + {model[bflower]} =&quot;, <br>        f&quot;{model[yflower].as_long() + model[rflower].as_long() + model[bflower].as_long()}&quot;<br>    )<br>else:<br>    print(&quot;unsat: No solution found.&quot;)</pre><p>I think everything is straight forward except one thing why ‚Äú<em>.as_long()‚Äù</em>? That‚Äôs because <em>model[variable]</em> is not <em>Int</em>,<em> </em>but<em> </em>class <em>z3.z3.IntNumRef.</em></p><p>When we dive a little bit deeper and look how Z3 is actually solving these problems:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/752/1*4TO5cqFKNLvonWTaIp4Z3Q.png" /><figcaption>abstract path of Z3 solving¬†equation</figcaption></figure><h3>Solving reverse engineering challenge:</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/755/1*qD43cdqRfw1f1Wn-JKUKwg.png" /><figcaption>Decompiled binary using¬†Ghidra</figcaption></figure><p>What do we even see? It‚Äôs binary that checks whatever license format is right or not, the license is hardcoded under some if statement, which has to be true in order to crack the¬†binary.</p><p>The argc arguments is the number of arguments supplied we know we need to run the binary with at least one argument and the length is 32¬†bytes.</p><p>There are two approaches about this problem using Z3, we use it to solve as equation or with angr that will control flow of the program and try to brute force it until everything is¬†met.</p><p>We will apply Z3 by rewriting the if statement into equation (you don‚Äôt need to do it manually, help yourself, for example you can use global¬†replace)</p><p>There is a small catch with the conversion, the chars are from -128 to 127 and when they overflow it will move back and¬†forth.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/564/1*LxhfxKE7gq7nQ1qQGdTJqg.png" /><figcaption>Small C example of the char conversion</figcaption></figure><p>In order to solve this weird unusual acting we will use <em>BitVecs</em>, I thought of using a function to handle the logic, but I end up using <em>BitVecs</em> for the simplicity.</p><pre>from z3 import *<br><br><br>def check_license_with_z3():<br>    solver = Solver()<br>    # Create array of bitvecs with size of 32<br>    string = [BitVec(f&quot;string_{i}&quot;, 8) for i in range(32)]<br><br>    solver.add(<br>        string[29] == string[5] - string[3] + ord(&quot;F&quot;),<br>        string[2] + string[22] == string[13] + ord(&quot;{&quot;),<br>        string[12] + string[4] == string[5] + 0x1c,<br>        string[25] * string[23] == string[0] + string[17] + 0x17,<br>        string[27] * string[1] == string[5] + string[22] + -21,<br>        string[9] * string[13] == string[28] * string[3] + -9,<br>        string[9] == ord(&quot;p&quot;),<br>        string[19] + string[21] == string[6] + -128,<br>        string[16] == string[15] - string[11] + ord(&quot;0&quot;),<br>        string[7] * string[27] == string[1] * string[13] + ord(&quot;-&quot;),<br>        string[13] == string[18] + string[13] + -101,<br>        string[20] - string[8] == string[9] + ord(&quot;|&quot;),<br>        string[31] == string[8] - string[31] + -121,<br>        string[20] * string[31] == string[20] + 4,<br>        string[24] - string[17] == string[21] + string[8] + -23,<br>        string[7] + string[5] == string[5] + string[29] + ord(&quot;,&quot;),<br>        string[12] * string[10] == string[1] - string[11] + -36,<br>        string[31] * string[0] == string[26] + -27,<br>        string[1] + string[20] == string[10] + -125,<br>        string[18] == string[27] + string[14] + 2,<br>        string[30] * string[11] == string[21] + ord(&quot;D&quot;),<br>        string[5] * string[19] == string[1] + -44,<br>        string[13] - string[26] == string[21] + -127,<br>        string[23] == string[29] - string[0] + ord(&quot;X&quot;),<br>        string[19] == string[8] * string[13] + -23,<br>        string[6] + string[22] == string[3] + ord(&quot;S&quot;),<br>        string[12] == string[26] + string[7] + -114,<br>        string[16] == string[18] - string[5] + ord(&quot;3&quot;),<br>        string[30] - string[8] == string[29] + -77,<br>        string[20] - string[11] == string[3] + -76,<br>        string[16] - string[7] == string[17] + ord(&quot;f&quot;),<br>        string[1] + string[21] == string[11] + string[18] + ord(&quot;+&quot;),<br>    )<br><br>    if solver.check() == sat:<br>        model = solver.model()<br>        print(<br>            &quot;&quot;.join([<br>                chr(c.as_long())<br>                for c in [model.eval(string[i]) for i in range(len(string))]<br>            ])<br>        )<br>        print(&quot;License Correct&quot;)<br>        return True<br>    else:<br>        print(&quot;License Invalid&quot;)<br>        return False</pre><p>(Bonus if we want to just get the string ‚ÄúLicense Correct‚Äù, it‚Äôs done by overwriting the if instruction.)</p><h3><strong>Conclusion</strong></h3><p>We‚Äôve learnt about Z3, the most fundamental terminology in Z3, and how to solve basic problems with¬†Z3.</p><p>With a little knowledge about Z3, you will be able to solve complex problems like rubic cube, sudoku, magic square and <a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm">lot¬†more</a>.</p><p>If you enjoyed this article, clapüëã and follow me! Thanks for reading! Looking forward to seeing you in the¬†future.</p><h4>More Resources</h4><p>Exemplar challenges: <a href="https://github.com/PwnFunction/learn-z3">https://github.com/PwnFunction/learn-z3</a><br>Docs: <a href="https://github.com/Z3Prover/z3/wiki#background">https://github.com/Z3Prover/z3/wiki#background</a><br>YouTube explanation: <a href="https://www.youtube.com/watch?v=EacYNe7moSs">https://www.youtube.com/watch?v=EacYNe7moSs</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=595d4de2719c" width="1" height="1" alt="">
